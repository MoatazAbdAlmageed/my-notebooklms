<!DOCTYPE html>
<html data-bs-theme="dark" lang="en" dir="ltr">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title></title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

    <link rel="stylesheet" href="../style.css">
</head>

<body>
    <div class="container">
        <div class="row">
            <div class="col-12">




                <p>Ahlan! That is a great request. Before we start building mobile apps with React Native, we must first
                    understand the foundation: <strong>React</strong>. Think of this chapter as learning the alphabet
                    before writing a beautiful story. We will go through everything step by step, using simple, clear
                    language.</p>
                <p>Chapter 1 is called: <strong>Learning the Basics: A Whistle-Stop Tour of React</strong>.</p>
                <hr>
                <h2 id="step-1-what-is-react-">Step 1: What is React?</h2>
                <p><strong>Simple Explanation:</strong> React is like a helpful assistant (a JavaScript library) that
                    specializes in building the parts of an application that the user sees (the <strong>User Interface,
                        or UI</strong>). It was created by the teams at Facebook and Instagram.</p>
                <p>The main goal of React is not &quot;Write once, run everywhere,&quot; which is difficult because of
                    different devices (web, mobile, tablets). Instead, React&#39;s guiding principle is
                    <strong>&quot;Learn once, write anywhere&quot;</strong>. If you know React, you can build for many
                    different platforms, including mobile with React Native.
                </p>
                <h3 id="why-do-we-use-react-advantages-">Why Do We Use React? (Advantages)</h3>
                <p>We use React because it solves a big problem: how to build <strong>large applications</strong> where
                    the data <strong>changes frequently</strong>.</p>
                <ol>
                    <li><strong>It uses JavaScript heavily:</strong> Traditionally, the look (HTML) and the actions
                        (JavaScript) were kept separate. React combines them into unified units called components, which
                        is easier to extend and maintain.</li>
                    <li><strong>It makes UIs reusable (Components):</strong> React breaks the UI into many small,
                        individual building blocks.</li>
                    <li><strong>It is blazing fast:</strong> This is thanks to the Virtual DOM (VDOM).</li>
                    <li><strong>It keeps things simple:</strong> It uses a &quot;One-way data flow,&quot; meaning data
                        moves predictably, making it easy to fix problems.</li>
                </ol>
                <hr>
                <h2 id="step-2-the-magic-of-the-virtual-dom-vdom-">Step 2: The Magic of the Virtual DOM (VDOM)</h2>
                <p><strong>Simple Explanation:</strong> The <strong>DOM (Document Object Model)</strong> is how your web
                    browser shows your website. Changing the actual DOM is one of the slowest jobs a computer does. To
                    solve this, React keeps a lightweight, <strong>Virtual Copy</strong> of the DOM, called the
                    <strong>VDOM</strong>.
                </p>
                <p><strong>How it works (The Analogy):</strong> Imagine you are editing a long, physical book.</p>
                <ul>
                    <li><strong>The Real DOM:</strong> This is the actual published book. Changing one sentence means
                        reprinting and rebinding the entire page, which is slow and expensive.</li>
                    <li><strong>The Virtual DOM (VDOM):</strong> This is a super-fast digital draft copy of the book.
                    </li>
                </ul>
                <p><strong>How React uses the VDOM:</strong></p>
                <ol>
                    <li>When data changes, React quickly generates a new Virtual DOM copy (a <strong>VTree</strong>).
                    </li>
                    <li>React then uses a smart <strong>&quot;diffing algorithm&quot;</strong> to quickly compare the
                        <em>new</em> VDOM with the <em>old</em> VDOM.
                    </li>
                    <li>The algorithm finds <strong>only the small differences</strong> (the &quot;stream of DOM
                        operations&quot;).</li>
                    <li>Finally, React updates <strong>only those specific, tiny changed parts</strong> on the real
                        browser DOM.</li>
                </ol>
                <p><strong>Practical Example:</strong> You have a social media feed with 100 posts. You click
                    &quot;Like&quot; on one post.</p>
                <ul>
                    <li><em>Without VDOM:</em> The whole screen might try to update, causing delays.</li>
                    <li><em>With VDOM:</em> React only updates the small number next to the &quot;Like&quot; button,
                        making the app feel <strong>blazing fast</strong>.</li>
                </ul>
                <hr>
                <h2 id="step-3-one-way-data-flow-the-predictable-path-">Step 3: One-Way Data Flow (The Predictable Path)
                </h2>
                <p><strong>Simple Explanation:</strong> This is the system React uses to manage how information moves
                    inside your application. <strong>One-way data flow</strong> means data always flows in a single
                    direction.</p>
                <h3 id="the-problem-with-the-old-way-two-way-data-binding-">The Problem with the Old Way (Two-Way Data
                    Binding)</h3>
                <ul>
                    <li>The traditional way (used by many MVC frameworks) is often called <strong>two-way data
                            binding</strong>.</li>
                    <li><strong>Analogy (The Spaghetti Problem):</strong> Imagine a bowl of spaghetti. If you pull on
                        one noodle (data), it might unexpectedly pull five other noodles (views/models) you didn&#39;t
                        mean to change. In large apps, this leads to an &quot;explosion of arrows&quot; and
                        <strong>spaghetti relationships</strong>, making it almost impossible to know <em>why</em> your
                        data changed. This can even result in infinite event loops.
                    </li>
                </ul>
                <h3 id="react-s-solution-one-way-flow-">React’s Solution (One-Way Flow)</h3>
                <p>React simplifies everything. Data starts in a main Component, flows <strong>down</strong> to child
                    components, and any change (Event) flows <strong>back up</strong> to the main component to update
                    the data, starting the process over (Action -&gt; View -&gt; Data Update).</p>
                <ul>
                    <li><strong>Benefit:</strong> Things are simple. You always know exactly where the data is coming
                        from and where it is going. This makes the application easier to maintain and test. This concept
                        is based on <strong>Separation of Concerns (SoC)</strong>, dividing the program into distinct,
                        isolated sections.</li>
                </ul>
                <hr>
                <h2 id="step-4-introduction-to-components-building-blocks-">Step 4: Introduction to Components (Building
                    Blocks)</h2>
                <p><strong>Simple Explanation:</strong> <strong>Components</strong> are the most basic and fundamental
                    parts of a React application. They are like <strong>reusable building blocks</strong> (or widgets)
                    that define both how a piece of the screen looks and how it works.</p>
                <h3 id="key-ideas-about-components-">Key Ideas About Components:</h3>
                <ol>
                    <li><strong>Reusable:</strong> Components are designed to be totally self-contained (encapsulated),
                        making them easy to test and reuse across your app.</li>
                    <li><strong>Templates + Logic:</strong> Components combine the look (like HTML/templates) and the
                        behavior (logic/JavaScript) intimately, which solves the problem of trying to attach behavior to
                        separate HTML elements.</li>
                    <li><strong>JSX:</strong> React uses a special syntax extension called <strong>JSX</strong>, which
                        looks like HTML but is actually JavaScript. This allows you to generate HTML elements directly
                        from JavaScript.</li>
                </ol>
                <h3 id="simple-component-code-example-">Simple Component Code Example:</h3>
                <p>Let&#39;s look at a basic component structure (similar to <code>App.js</code>):</p>
                <pre><code class="lang-javascript"><span class="hljs-comment">// Block 1: Setup</span>
<span class="hljs-keyword">import</span> <span class="hljs-type">React</span>, { <span class="hljs-type">Component</span> } from <span class="hljs-symbol">'reac</span>t';
<span class="hljs-comment">// Block 2: The Component Class</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
    <span class="hljs-comment">// Block 3: The Renderer</span>
    render() {
        <span class="hljs-keyword">return</span> (
            &lt;div className=<span class="hljs-string">"App"</span>&gt;
                &lt;p&gt;<span class="hljs-type">Hello</span> <span class="hljs-type">World</span>&lt;/p&gt;
            &lt;/div&gt;
        );
    }
}
<span class="hljs-comment">// Block 4: Making it available</span>
export <span class="hljs-keyword">default</span> <span class="hljs-type">App</span>;
</code></pre>
                <p><strong>Code Explanation (Step-by-Step):</strong></p>
                <ul>
                    <li><strong><code>import React, { Component } from &#39;react&#39;;</code></strong> (Block 1)<ul>
                            <li><strong>What it does:</strong> It pulls in the main React code we need to build things.
                            </li>
                            <li><strong>Why it&#39;s written this way:</strong> We need <code>React</code> to define the
                                component and <code>Component</code> because we are creating a class that
                                &quot;extends&quot; (inherits from) the main React Component class API.</li>
                        </ul>
                    </li>
                    <li><strong><code>class App extends Component { ... }</code></strong> (Block 2)<ul>
                            <li><strong>What it does:</strong> This creates our main component, named <code>App</code>.
                            </li>
                            <li><strong>How to use it:</strong> When we want to show this component on screen, we just
                                use a tag like <code>&lt;App /&gt;</code>.</li>
                        </ul>
                    </li>
                    <li><strong><code>render() { return ( ... JSX code ... ); }</code></strong> (Block 3)<ul>
                            <li><strong>What it does:</strong> The <code>render</code> function is responsible for
                                describing what the component shows on the screen (the UI). It uses JSX markup (the
                                HTML-like code).</li>
                            <li><strong>Important Tip:</strong> The <code>render</code> function must be a <strong>pure
                                    function</strong> (immutable). You should <strong>never</strong> try to update data
                                or state inside <code>render()</code> because it will call <code>render()</code> again,
                                causing an infinite loop.</li>
                        </ul>
                    </li>
                    <li><strong><code>export default App;</code></strong> (Block 4)<ul>
                            <li><strong>What it does:</strong> This makes the <code>App</code> component available for
                                other files to use (or import).</li>
                        </ul>
                    </li>
                </ul>
                <h3 id="creating-a-stateless-component-simple-function-component-">Creating a Stateless Component
                    (Simple Function Component)</h3>
                <p><strong>Simple Explanation:</strong> If your component is only for showing information and
                    <strong>never needs to manage changing data</strong> internally, you can use a simpler
                    <strong>functional approach</strong>. These are often called <strong>stateless components</strong>.
                </p>
                <pre><code class="lang-javascript"><span class="hljs-comment">// Message.js</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">const</span> SimpleMessage = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> Hello to StatelessComponent <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> SimpleMessage;
</code></pre>
                <ul>
                    <li><strong>Benefit:</strong> This is the preferred way if the data is not changing, as it has less
                        extra code (no <code>class</code>, no <code>extends</code>, no <code>constructor</code>) and is
                        easier to test.</li>
                </ul>
                <hr>
                <h2 id="step-5-properties-props-">Step 5: Properties (Props)</h2>
                <p><strong>Simple Explanation:</strong> <strong>Props</strong> (short for properties) are how a
                    <strong>Parent Component</strong> passes <strong>fixed settings or data DOWN</strong> to its
                    <strong>Child Components</strong>.
                </p>
                <p><strong>Key Rule:</strong> Props are <strong>immutable</strong>, meaning they <strong>cannot be
                        changed</strong> by the child component that receives them.</p>
                <p><strong>Analogy:</strong> If you build a house (Parent Component), you give the painter (Child
                    Component) a specific color (Prop) to use. The painter can use the color, but they cannot change the
                    color&#39;s formula.</p>
                <h3 id="practical-example-passing-a-message-">Practical Example (Passing a Message)</h3>
                <p><strong>Step 1: The Parent Component (App.js) gives the message.</strong></p>
                <p>In the parent component, you initialize the child component and pass data using an attribute, just
                    like in HTML:</p>
                <pre><code class="lang-javascript">// Parent <span class="hljs-keyword">Component</span> (App.js)
// Initializing Message <span class="hljs-keyword">component</span> <span class="hljs-keyword">with</span> a prop named <span class="hljs-symbol">'text</span>'
&lt;Message <span class="hljs-literal">text</span>=<span class="hljs-string">"Hello to React World"</span> /&gt;
</code></pre>
                <p><strong>Step 2: The Child Component (Message.js) reads the message.</strong></p>
                <p>The child component receives the props and uses <code>this.props.text</code> to display it.</p>
                <pre><code class="lang-javascript"><span class="hljs-comment">// Child Component (Message.js)</span>
<span class="hljs-keyword">import</span> <span class="hljs-type">React</span>, { <span class="hljs-type">Component</span> } from <span class="hljs-symbol">'reac</span>t';

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
    render() {
        <span class="hljs-keyword">return</span> (
            &lt;div&gt;
                {<span class="hljs-keyword">this</span>.props.text} {<span class="hljs-comment">/* Reading the 'text' prop */</span>}
            &lt;/div&gt;
        );
    }
}
export <span class="hljs-keyword">default</span> <span class="hljs-type">Message</span>;
</code></pre>
                <p><strong>Result:</strong> The browser screen shows the text: &quot;Hello to React World&quot;.</p>
                <h3 id="protecting-your-props-validation-">Protecting Your Props (Validation)</h3>
                <p><strong>Simple Explanation:</strong> As your application grows, you must ensure that your component
                    receives the <strong>correct type of data</strong> (e.g., that <code>text</code> is a string, not a
                    number). React uses <strong>Prop Validation</strong> to check the incoming data before the component
                    runs.</p>
                <p><strong>Code Example (Making sure the message is required):</strong></p>
                <pre><code class="lang-javascript"><span class="hljs-keyword">import</span> <span class="hljs-type">React</span>, { <span class="hljs-type">Component</span> } from <span class="hljs-symbol">'reac</span>t';
<span class="hljs-keyword">import</span> <span class="hljs-type">PropTypes</span> from <span class="hljs-symbol">'prop</span>-types'; <span class="hljs-comment">// Step 1: Import PropTypes library</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
    <span class="hljs-comment">// ... render function remains the same ...</span>
}

<span class="hljs-comment">// Step 2: Define validation rules for the component</span>
<span class="hljs-type">Message</span>.propTypes = {
    text: <span class="hljs-type">PropTypes</span>.string.isRequired <span class="hljs-comment">// We say 'text' must be a string and it is REQUIRED.</span>
};
export <span class="hljs-keyword">default</span> <span class="hljs-type">Message</span>;
</code></pre>
                <ul>
                    <li><strong>Where/How to use it:</strong> If you run the app and forget to pass the
                        <code>text</code> prop (e.g., you write <code>&lt;Message /&gt;</code> instead of
                        <code>&lt;Message text=&quot;Hi&quot; /&gt;</code>), your app console will show an <strong>error
                            or warning</strong>, helping you find the bug quickly.
                    </li>
                    <li><strong>Default Values:</strong> You can also provide a default value (like a fallback) if the
                        parent component doesn&#39;t pass a prop, using <code>static defaultProps</code>.</li>
                </ul>
                <hr>
                <h2 id="step-6-state">Step 6: State</h2>
                <p><strong>Simple Explanation:</strong> Unlike Props (which are fixed data coming from outside),
                    <strong>State</strong> is data that a component <strong>keeps track of internally</strong> and that
                    is designed to <strong>change over time</strong>. When the State changes, the component
                    automatically <strong>rerenders</strong> (updates itself).
                </p>
                <p><strong>Key Difference:</strong> Props are for initialization (static values), while State is for
                    internal, private data that affects how the component renders.</p>
                <p><strong>Analogy:</strong> If Props are the fixed dimensions of a ruler, the State is the flexible
                    measuring tape that changes as you pull it out.</p>
                <h3 id="practical-example-tracking-user-input-">Practical Example (Tracking User Input)</h3>
                <p>We want to create a text box where, as the user types, the welcome message updates instantly.</p>
                <p><strong>Step 1: Set the Initial State and Bind Functions (The Constructor)</strong></p>
                <p>The constructor is the <strong>only place</strong> where you can directly set or change the initial
                    state.</p>
                <pre><code class="lang-javascript"><span class="hljs-comment">// Inside Welcome.js component class</span>
<span class="hljs-keyword">constructor</span>(props) {
    <span class="hljs-keyword">super</span>(props);
    <span class="hljs-comment">// 1. Tell React that when handleChange is called, 'this' refers to this component</span>
    <span class="hljs-keyword">this</span>.handleChange = <span class="hljs-keyword">this</span>.handleChange.bind(<span class="hljs-keyword">this</span>);
    <span class="hljs-comment">// 2. Set the starting internal data (State)</span>
    <span class="hljs-keyword">this</span>.state = { text: <span class="hljs-string">''</span> };
}
</code></pre>
                <ul>
                    <li><strong><code>constructor(props)</code>:</strong> This function runs when the component is
                        created.</li>
                    <li><strong><code>super(props)</code>:</strong> This calls the parent React Component&#39;s
                        constructor, which is needed for proper initialization.</li>
                    <li><strong><code>this.state = { text: &#39;&#39; };</code>:</strong> We initialize the state
                        object. The <code>text</code> property starts as an empty string.</li>
                </ul>
                <p><strong>Step 2: Define the Change Function (<code>handleChange</code>)</strong></p>
                <p>This function is called every time the user types a letter in the text box.</p>
                <pre><code class="lang-javascript">handleChange(e) {
    // We MUST use this.<span class="hljs-built_in">set</span>State() <span class="hljs-keyword">to</span> change <span class="hljs-keyword">state</span> (except <span class="hljs-keyword">in</span> the constructor)
    this.<span class="hljs-built_in">set</span>State({ text: e.target.value });
}
</code></pre>
                <ul>
                    <li><strong><code>this.setState({...})</code>:</strong> This is the special method used to update
                        the state. It tells React: &quot;This data changed! Please re-render the component!&quot;</li>
                    <li><strong><code>e.target.value</code>:</strong> This is the new text typed by the user.</li>
                </ul>
                <p><strong>Step 3: Render the UI and Link the State (JSX)</strong></p>
                <p>We connect the input box and the display text to the internal state.</p>
                <pre><code class="lang-javascript">render() {
    <span class="hljs-keyword">return</span> (
        &lt;div&gt;
            &lt;input
                id=<span class="hljs-string">"text"</span>
                onChange={<span class="hljs-keyword">this</span>.handleChange} <span class="hljs-comment">// When text changes, call the handleChange function</span>
                value={<span class="hljs-keyword">this</span>.state.text}     <span class="hljs-comment">// The text box value is controlled by the current state</span>
            /&gt;
            &lt;br /&gt;
            Welcome {<span class="hljs-keyword">this</span>.state.text} <span class="hljs-comment">// Display the current state value here</span>
        &lt;/div&gt;
    );
}
</code></pre>
                <p><strong>Result:</strong> When you type, <code>onChange</code> calls <code>handleChange</code>, which
                    calls <code>this.setState()</code>. React sees the state update and instantly updates the text shown
                    in the <code>Welcome {this.state.text}</code> line, resulting in a live, real-time update.</p>
                <hr>
                <h2 id="chapter-1-summary-and-key-takeaways">Chapter 1 Summary and Key Takeaways</h2>
                <h3 id="short-chapter-summary">Short Chapter Summary</h3>
                <p>Chapter 1 provides a quick introduction to the fundamental concepts of React, which serves as the
                    base for React Native. The core concepts explained are the <strong>Virtual DOM (VDOM)</strong>,
                    which enhances performance by minimizing direct UI updates, and the strict <strong>One-Way Data
                        Flow</strong>, which ensures application predictability and maintainability. The chapter also
                    introduced <strong>Components</strong> as the basic, reusable building blocks of the UI, explaining
                    how they manage information through fixed <strong>Properties (Props)</strong> passed from above, and
                    internal, changing <strong>State</strong>. Finally, it demonstrated how to set up a basic React
                    application using <code>create-react-app</code>.</p>
                <h3 id="main-key-ideas-to-remember">Main Key Ideas to Remember</h3>
                <ul>
                    <li><strong>React is a Library for UIs:</strong> It&#39;s focused solely on building the user
                        interface.</li>
                    <li><strong>VDOM = Speed:</strong> The Virtual DOM is a fast, virtual copy of the real browser DOM
                        that uses a diffing algorithm to only update the small parts of the screen that actually
                        changed.</li>
                    <li><strong>One-Way Flow is Predictable:</strong> Data travels in one direction (Parent to Child),
                        eliminating messy two-way data binding problems (spaghetti code).</li>
                    <li><strong>Components are Reusable:</strong> They are encapsulated units combining the look and the
                        logic.</li>
                    <li><strong>Props are Immutable:</strong> They are fixed values passed <strong>down</strong> from
                        the parent, used for initialization.</li>
                    <li><strong>State is Mutable:</strong> It is internal data that can <strong>change</strong> within
                        the component itself, triggering an automatic re-render. You must update state using
                        <code>this.setState()</code>.
                    </li>
                </ul>
                <h3 id="practical-examples-i-can-try-right-away">Practical Examples I Can Try Right Away</h3>
                <ol>
                    <li>
                        <p><strong>Passing Props (Fixed Message):</strong></p>
                        <ul>
                            <li>Create a simple <code>Greeting</code> component.</li>
                            <li>In the parent <code>App</code> component, render it like this:
                                <code>&lt;Greeting name=&quot;Hassan&quot; /&gt;</code>.
                            </li>
                            <li>In the <code>Greeting</code> component, display the name using
                                <code>{this.props.name}</code>. (This confirms you understand Props are read-only
                                input).
                            </li>
                        </ul>
                    </li>
                    <li>
                        <p><strong>Managing State (Simple Counter):</strong></p>
                        <ul>
                            <li>Create a <code>Counter</code> component with a starting <code>state</code> of
                                <code>{ count: 0 }</code> in the constructor.
                            </li>
                            <li>Display the current count: <code>{this.state.count}</code>.</li>
                            <li>Create a button linked to a function that calls
                                <code>this.setState({ count: this.state.count + 1 })</code>. (This confirms you can
                                change internal data and trigger a re-render).
                            </li>
                        </ul>
                    </li>
                </ol>
                <h3 id="quick-tips-to-help-me-apply-what-i-learned">Quick Tips to Help Me Apply What I Learned</h3>
                <ol>
                    <li><strong>Ask: &quot;Should this change?&quot;</strong> If a piece of data never changes or is
                        passed down from the parent, use a <strong>Prop</strong>. If the data must change based on user
                        actions inside the component, use <strong>State</strong>.</li>
                    <li><strong>Never Use Direct Assignment:</strong> Outside of the <code>constructor</code>, always
                        update data using the official function <code>this.setState()</code>—never try to change
                        <code>this.state.count = 5</code> directly.
                    </li>
                    <li><strong>Start Small with Components:</strong> Before writing a huge file, try to break the UI
                        down into the smallest possible reusable pieces (like a button, a label, or an input box).</li>
                </ol>
                <h3 id="short-quiz-questions-to-test-basic-understanding">Short Quiz Questions to Test Basic
                    Understanding</h3>
                <ol>
                    <li>What does VDOM stand for, and why is it important for application speed?</li>
                    <li>If you want to change data <em>inside</em> a component based on a user click, should you use
                        Props or State?</li>
                    <li>In React&#39;s data flow, can a child component directly modify the Props it receives from its
                        parent? (Yes or No)</li>
                </ol>




            </div>
        </div>

    </div>


    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>


    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" //
        integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+Y2XIdI6kB1jRVVbR4D9M1zYjFq2D" //
        crossorigin="anonymous"></script>

    <script src="../script.js"> </script>


</body>

</html>