<!DOCTYPE html>
<html data-bs-theme="dark" lang="en" dir="ltr">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title></title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

    <link rel="stylesheet" href="../style.css">
</head>

<body>
    <div class="container">
        <div class="row">
            <div class="col-12">


                <p>Ahlan! Chapter 4 is where we stop thinking about deep data management (Chapter 3) and start thinking
                    about making our app beautiful and usable.</p>
                <p>Chapter 4 is titled: <strong>Canvas, Brush, and Paint: Working with the User Interface</strong>. This
                    chapter teaches you how to design the layout of your screens, manage the movement between screens
                    (navigation), and add basic features like clicking and scrolling.</p>
                <hr>
                <h2 id="step-1-navigating-between-screens">Step 1: Navigating Between Screens</h2>
                <p><strong>Simple Explanation:</strong> <strong>React Navigation</strong> is the tool (a JavaScript
                    library) we use to handle how users move from one screen to another in the app (like clicking a link
                    and going to a new page). It handles the differences between how iOS and Android manage these
                    transitions (routing).</p>
                <h3 id="practical-example-creating-the-navigation-stack-">Practical Example (Creating the Navigation
                    Stack)</h3>
                <p>Imagine our HouseShare app needs a Home Screen and an About Screen.</p>
                <p><strong>A. Installation</strong>
                    First, you need to add the React Navigation package to your project:
                    <code>yarn add react-navigation</code>
                </p>
                <p><strong>B. Defining the Screens in JavaScript</strong></p>
                <ol>
                    <li><strong>Create the Screens:</strong> You create two separate component files,
                        <code>HomeScreen.js</code> and <code>AboutScreen.js</code>.</li>
                    <li><strong>Define the Navigator:</strong> In your main <code>App.js</code> file, you use
                        <code>createStackNavigator</code> to tell React Native which screens exist and how to move
                        between them.</li>
                </ol>
                <p><strong>Code Idea (in <code>App.js</code>):</strong></p>
                <pre><code class="lang-javascript"><span class="hljs-keyword">import</span> { createStackNavigator } from <span class="hljs-symbol">'react</span>-navigation'; <span class="hljs-comment">// A. Get the stack creator</span>

<span class="hljs-comment">// B. Define the list of screens (the Stack)</span>
const <span class="hljs-type">AppNavigator</span> = createStackNavigator({
    <span class="hljs-type">Home</span>: {
        screen: <span class="hljs-type">HomeScreen</span> <span class="hljs-comment">// The component for the Home screen</span>
    },
    <span class="hljs-type">About</span>: {
        screen: <span class="hljs-type">AboutScreen</span> <span class="hljs-comment">// The component for the About screen</span>
    }
});

export <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    render() {
        <span class="hljs-keyword">return</span> &lt;<span class="hljs-type">AppNavigator</span> /&gt;; <span class="hljs-comment">// C. Load the navigator component</span>
    }
}
</code></pre>
                <ul>
                    <li><strong><code>createStackNavigator</code>:</strong> This function returns a React component that
                        manages the navigation history and transitions.</li>
                    <li><strong><code>Home: { screen: HomeScreen }</code></strong>: This line maps the friendly name
                        &#39;Home&#39; to the actual component <code>HomeScreen</code>.</li>
                </ul>
                <p><strong>C. Moving Between Screens</strong>
                    When you define a screen in <code>createStackNavigator</code>, React Navigation automatically gives
                    that screen&#39;s component a special property: <code>this.props.navigation</code>. You use this to
                    move.</p>
                <p><strong>Code Idea (in <code>HomeScreen.js</code> to navigate to About):</strong></p>
                <pre><code class="lang-javascript"><span class="hljs-comment">// Inside the render function:</span>
<span class="hljs-keyword">const</span> { navigate } = <span class="hljs-keyword">this</span>.props.navigation; <span class="hljs-comment">// 1. Get the navigation function</span>

&lt;Button
    title=<span class="hljs-string">"Go About Page"</span>
    onPress={() =&gt; navigate(<span class="hljs-string">'About'</span>)} <span class="hljs-comment">// 2. Call navigate with the screen's route name ('About')</span>
/&gt;
</code></pre>
                <ul>
                    <li><strong><code>navigate(&#39;About&#39;)</code></strong>: This command tells the stack navigator
                        to push the <code>AboutScreen</code> onto the screen stack. This provides a drill-down interface
                        and manages navigation history.</li>
                </ul>
                <hr>
                <h2 id="step-2-flexbox-the-layout-system-">Step 2: Flexbox (The Layout System)</h2>
                <p><strong>Simple Explanation:</strong> <strong>Flexbox</strong> is the layout model used in React
                    Native for styling components. It is similar to the CSS Flex Box Layout but rewritten specifically
                    for iOS. The main idea of Flexbox is to make a layout that <strong>automatically adjusts</strong>
                    based on the screen size or device orientation (like rotating the phone).</p>
                <p><strong>Analogy:</strong> Flexbox is like having adjustable shelves in a box. No matter how you turn
                    the box (portrait or landscape), the shelves automatically take up the right proportion of space
                    inside.</p>
                <h3 id="key-flexbox-properties">Key Flexbox Properties</h3>
                <ol>
                    <li>
                        <p><strong><code>flex: value</code> (The Ratio)</strong></p>
                        <ul>
                            <li><strong>What it does:</strong> This property defines the <strong>relative size</strong>
                                of a component inside its container. The value can be an integer or a decimal.</li>
                            <li><strong>Practical Example:</strong> If you have a screen container with two boxes, and
                                you set one to <code>flex: 2</code> and the other to <code>flex: 1</code>, the screen
                                will be divided so the first box is twice as large as the second (<strong>a 2:1
                                    ratio</strong>). If you then add a third box with <code>flex: 2</code>, the screen
                                is divided in a <strong>2:1:2 ratio</strong>.</li>
                        </ul>
                    </li>
                    <li>
                        <p><strong><code>flexDirection</code> (The Axis)</strong></p>
                        <ul>
                            <li><strong>What it does:</strong> This defines the main direction in which child elements
                                are organized inside their container. It controls if they stack vertically or
                                horizontally.</li>
                            <li><strong>Values:</strong> It can be set to <code>&#39;column&#39;</code> (the default,
                                stacks items vertically, one under the other) or <code>&#39;row&#39;</code> (stacks
                                items horizontally, next to each other).</li>
                        </ul>
                    </li>
                </ol>
                <h3 id="simple-code-example-using-ratios-">Simple Code Example (Using Ratios)</h3>
                <p>Let&#39;s divide a screen into a header and a body in a 1:2 ratio.</p>
                <pre><code class="lang-javascript"><span class="hljs-built_in">var</span> styles = StyleSheet.create({
    container: {
        flex: <span class="hljs-number">1</span>, <span class="hljs-comment">// The container should fill the whole screen</span>
        flexDirection: <span class="hljs-string">'column'</span> <span class="hljs-comment">// Stack items vertically</span>
    },
    <span class="hljs-keyword">header</span>: {
        flex: <span class="hljs-number">1</span>, <span class="hljs-comment">// Takes 1 part of the total space (1/3)</span>
        backgroundColor: <span class="hljs-string">'blue'</span>
    },
    body: {
        flex: <span class="hljs-number">2</span>, <span class="hljs-comment">// Takes 2 parts of the total space (2/3)</span>
        backgroundColor: <span class="hljs-string">'white'</span>
    }
});
</code></pre>
                <ul>
                    <li><strong>How to Use it:</strong> You place the components inside the main container:
                        <pre><code class="lang-javascript"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.container}</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.header}</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.body}</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>
</code></pre>
                    </li>
                    <li><strong>Result:</strong> The screen shows a blue box (Header) taking up one-third of the screen,
                        and a white box (Body) taking up the remaining two-thirds. If you rotate the phone, these ratios
                        remain correct.</li>
                </ul>
                <hr>
                <h2 id="step-3-making-elements-clickable-touchablehighlight-">Step 3: Making Elements Clickable
                    (TouchableHighlight)</h2>
                <p><strong>Simple Explanation:</strong> To let a user interact with a piece of text or an image, you
                    need to wrap it in a component that detects a touch. <strong>TouchableHighlight</strong> is a
                    component that makes a view clickable and provides a visual response (highlighting) when pressed.
                </p>
                <h3 id="practical-example-a-clickable-image-">Practical Example (A Clickable Image)</h3>
                <p>We want to make the HouseShare image clickable to take the user to the list of properties.</p>
                <p><strong>Code Example (in <code>HomeScreen.js</code>):</strong></p>
                <pre><code class="lang-javascript">&lt;TouchableHighlight
    style={styles.topBox}
    onPress={() =&gt; navigate(<span class="hljs-string">'HomeListScreen'</span>)} // What <span class="hljs-keyword">to</span> do <span class="hljs-keyword">when</span> clicked
&gt;
    &lt;Image
        style={styles.homeBanner}
        source={require(<span class="hljs-string">'../assets/house.png'</span>)}
    /&gt;
&lt;/TouchableHighlight&gt;
</code></pre>
                <ul>
                    <li><strong><code>TouchableHighlight</code></strong>: This component wraps the content (the image).
                    </li>
                    <li><strong><code>onPress={...}</code></strong>: This is the mandatory attribute that defines the
                        action when the touch event occurs. Here, we use the navigation function to move to the
                        <code>HomeListScreen</code>.</li>
                </ul>
                <hr>
                <h2 id="step-4-displaying-lists-flatlist-">Step 4: Displaying Lists (FlatList)</h2>
                <p><strong>Simple Explanation:</strong> When you have a long list of data (like all the available
                    properties, or a social media feed), you must display it efficiently.
                    <strong><code>&lt;FlatList&gt;</code></strong> is the recommended component for displaying long,
                    vertically scrolling lists of dynamic data.</p>
                <p><strong>Why <code>FlatList</code> is important (Efficiency):</strong> Unlike
                    <strong><code>&lt;ScrollView&gt;</code></strong>, which renders <strong>all</strong> its child
                    components at once (using a lot of memory), <code>&lt;FlatList&gt;</code> renders items
                    <strong>lazily</strong>—meaning it only renders items right before they are about to appear on the
                    screen, and removes items that scroll far off screen. This saves memory and processing time, which
                    keeps your app fast.</p>
                <h3 id="practical-example-listing-properties-">Practical Example (Listing Properties)</h3>
                <p>To use <code>FlatList</code>, you must provide it with data and tell it how to display each item.</p>
                <p><strong>Code Idea (in <code>HomeListScreen.js</code>):</strong></p>
                <pre><code class="lang-javascript">// 1. Data Source (an<span class="hljs-built_in"> array </span>of objects)<span class="hljs-built_in">
const </span>MOCK_DATA = [
    { name: 'Mr. Johns Conch house', address: '12th Street, Neverland', images: 'http://hmp.me/ol5'},
    // ... more property objects ...
];

// 2. The FlatList component
&lt;FlatList
    data={MOCK_DATA} // The<span class="hljs-built_in"> array </span>of data to display
    renderItem={({item}) =&gt; &lt;HouseItem {...item}/&gt;} // How to render each item
    keyExtractor={(item, index) =&gt; index.toString()} // Unique key for efficiency
/&gt;
</code></pre>
                <ul>
                    <li><strong><code>data={MOCK_DATA}</code></strong>: This property holds the source of information
                        (the array) for the list.</li>
                    <li><strong><code>renderItem={...}</code></strong>: This function takes one item from the data
                        source and returns the formatted component (<code>HouseItem</code>) to render it.</li>
                    <li><strong><code>keyExtractor={...}</code></strong>: This tells React which property to use as a
                        unique key for each item in the list, which is necessary for React&#39;s efficiency.</li>
                </ul>
                <hr>
                <h2 id="step-5-adding-animations">Step 5: Adding Animations</h2>
                <p><strong>Simple Explanation:</strong> Smooth visual effects are crucial for a great user experience.
                    React Native provides an <strong>Animated API</strong> to create different types of animations
                    easily.</p>
                <h3 id="key-animation-methods">Key Animation Methods</h3>
                <ul>
                    <li><strong><code>Animated.timing()</code></strong>: Used for animations based on a specific time
                        range (e.g., fade out over 2 seconds).</li>
                    <li><strong><code>Animated.spring()</code></strong>: Used for physics-based fluid motions (like
                        bouncing).</li>
                    <li><strong><code>Animated.parallel()</code></strong>: Used to start multiple animations at the same
                        time.</li>
                    <li><strong><code>Animated.sequence()</code></strong>: Used to run multiple animations one after the
                        other, waiting for the previous one to finish.</li>
                </ul>
                <h3 id="practical-example-a-fade-in-effect-">Practical Example (A Fade-In Effect)</h3>
                <p>We want a component to slowly fade in (appear) over 4 seconds.</p>
                <p><strong>Code Example (The <code>FadeInView</code> Component):</strong></p>
                <pre><code class="lang-javascript">// Step <span class="hljs-number">1</span>: Set up the initial <span class="hljs-keyword">state</span> <span class="hljs-keyword">for</span> the animation value
<span class="hljs-keyword">state</span> = {
    fadeAnim: new Animated.Value(<span class="hljs-number">0</span>), // Starting opacity at <span class="hljs-number">0</span> (invisible)
}

// Step <span class="hljs-number">2</span>: Start the animation when the component loads
componentDidMount() {
    Animated.timing(
        this.<span class="hljs-keyword">state</span>.fadeAnim, // The value <span class="hljs-keyword">to</span> animate
        {
            <span class="hljs-keyword">to</span>Value: <span class="hljs-number">1</span>, // Animate <span class="hljs-keyword">to</span> <span class="hljs-number">1</span> (fully visible)
            duration: <span class="hljs-number">4000</span>, // Over <span class="hljs-number">4000</span> milliseconds (<span class="hljs-number">4</span> seconds)
        }
    ).start(); // Start the process!
}

// Step <span class="hljs-number">3</span>: Link the animated value <span class="hljs-keyword">to</span> the style
render() {
    let { fadeAnim } = this.<span class="hljs-keyword">state</span>;
    return (
        <span class="hljs-variable">&lt;Animated.View style={{ opacity: fadeAnim }}&gt;</span>
            {this.props.children}
        &lt;/Animated.View&gt;
    );
}
</code></pre>
                <ul>
                    <li><strong><code>new Animated.Value(0)</code></strong>: Creates a special animated value that
                        starts at 0 (invisible).</li>
                    <li><strong><code>componentDidMount()</code></strong>: We start the animation here because this
                        function runs once when the component is loaded for the first time.</li>
                    <li><strong><code>Animated.timing()</code></strong>: This function defines a time-based animation
                        path.</li>
                    <li><strong><code>opacity: fadeAnim</code></strong>: This links the changing state value
                        (<code>fadeAnim</code>) to the component&#39;s <code>opacity</code> style. As
                        <code>fadeAnim</code> changes from 0 to 1, the component becomes visible.</li>
                </ul>
                <h2 id="-">---</h2>
                <h2 id="chapter-4-summary-and-practical-guide">Chapter 4 Summary and Practical Guide</h2>
                <h3 id="short-chapter-summary">Short Chapter Summary</h3>
                <p>Chapter 4 details how to structure and beautify the mobile app&#39;s User Interface (UI).
                    <strong>React Navigation</strong> is essential for managing screen transitions, creating an
                    organized stack of pages, and handling the core routing logic for both iOS and Android. The layout
                    is managed by <strong>Flexbox</strong>, a powerful model that uses relative size ratios
                    (<code>flex: 2</code>) and directions (<code>flexDirection: &#39;row&#39;</code>) to create
                    responsive designs that adjust automatically to different screen sizes. Components like
                    <strong>TouchableHighlight</strong> enable user interaction, while <strong>FlatList</strong> ensures
                    the efficient rendering of long, scrolling lists by only drawing items when they are about to be
                    visible. Finally, the <strong>Animated API</strong> is used to add smooth visual effects and
                    interactivity using time-based functions like <code>Animated.timing()</code>.</p>
                <h3 id="main-key-ideas-to-remember">Main Key Ideas to Remember</h3>
                <ul>
                    <li><strong>React Navigation for Routing:</strong> Use <code>createStackNavigator</code> and the
                        <code>navigate()</code> function to manage the movement between screens.</li>
                    <li><strong>Flexbox is Responsive:</strong> Flexbox manages layout using <strong>ratios
                            (<code>flex</code>)</strong> and stacking direction (<code>flexDirection</code>) to make
                        layouts flexible across different devices and orientations.</li>
                    <li><strong>TouchableHighlight for Clicks:</strong> Wrap any UI element (like text or an image) in
                        <code>TouchableHighlight</code> to make it clickable.</li>
                    <li><strong>FlatList for Efficiency:</strong> Always use <code>&lt;FlatList&gt;</code> (or
                        <code>&lt;SectionList&gt;</code>) instead of <code>&lt;ScrollView&gt;</code> for long lists,
                        because it saves memory by only rendering items lazily as the user scrolls.</li>
                    <li><strong>Animated API:</strong> Use the <code>Animated</code> API, specifically
                        <code>Animated.timing()</code> and <code>Animated.spring()</code>, for smooth and engaging UI
                        effects.</li>
                </ul>
                <h3 id="2-3-practical-examples-i-can-try-right-away">2–3 Practical Examples I Can Try Right Away</h3>
                <ol>
                    <li><strong>Flexbox Ratios Practice:</strong> Create a single screen and use three
                        <code>&lt;View&gt;</code> components inside it. Give them <code>flex: 1</code>,
                        <code>flex: 3</code>, and <code>flex: 1</code> respectively, and set different background colors
                        to see the 1:3:1 division instantly.</li>
                    <li><strong>Navigation and Click Test:</strong> Create a simple two-screen navigation setup (Home
                        and Profile) using <code>createStackNavigator</code>. Add a <code>&lt;Button&gt;</code> to the
                        Home Screen that uses <code>this.props.navigation.navigate(&#39;Profile&#39;)</code> to confirm
                        the routing works.</li>
                    <li><strong>FlatList Dummy Data:</strong> Use a simple JavaScript array of 10-20 fake names as the
                        <code>data</code> source for a <code>&lt;FlatList&gt;</code>. Ensure the <code>renderItem</code>
                        property is set up correctly to display each name in a <code>&lt;Text&gt;</code> component.</li>
                </ol>
                <h3 id="3-quick-tips-to-help-apply-what-i-learned">3 Quick Tips to Help Apply What I Learned</h3>
                <ol>
                    <li><strong>Think in Ratios, Not Pixels:</strong> When using Flexbox, try to define sizes using the
                        <code>flex</code> property (ratios) instead of fixed pixel sizes, especially for major
                        containers, so your layout works well on all devices.</li>
                    <li><strong>Learn Flexbox Alignment:</strong> Practice the alignment properties like
                        <code>justifyContent</code> (space along the main axis) and <code>alignItems</code> (space along
                        the perpendicular axis) to precisely position elements within their containers.</li>
                    <li><strong>Avoid ScrollView for Dynamic Lists:</strong> Make it a rule: If the list of items can
                        grow (like a list of messages or products), always use <code>FlatList</code> for better
                        performance and memory management.</li>
                </ol>
                <h3 id="3-short-quiz-questions-to-test-basic-understanding">3 Short Quiz Questions to Test Basic
                    Understanding</h3>
                <ol>
                    <li>What is the primary difference between how <code>&lt;ScrollView&gt;</code> and
                        <code>&lt;FlatList&gt;</code> render items, and which one is more memory efficient for very long
                        lists?</li>
                    <li>In React Navigation, what is the required function you call in a component (which is
                        automatically passed as a prop) to move the user to a different screen?</li>
                    <li>If a container component has <code>flexDirection: &#39;row&#39;</code>, how will the child
                        elements inside it be organized (stacked vertically or laid out horizontally)?</li>
                </ol>






            </div>
        </div>

    </div>


    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>


    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" //
        integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+Y2XIdI6kB1jRVVbR4D9M1zYjFq2D" //
        crossorigin="anonymous"></script>

    <script src="../script.js"> </script>


</body>

</html>