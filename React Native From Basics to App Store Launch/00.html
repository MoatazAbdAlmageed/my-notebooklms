<!DOCTYPE html>
<html data-bs-theme="dark" lang="en" dir="ltr">

<head>
  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Index</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
    integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

  <link rel="stylesheet" href="../style.css">
</head>

<body>
  <div class="container">
    <div class="row">
      <div class="col-12">

        <p>This text consists of excerpts from the second edition of <strong>React Native for Mobile
            Development</strong>, a technical guide authored by Akshat Paul and Abhishek Nalwaya, intended to instruct
          readers on creating cross-platform mobile applications. The material begins with an overview of core React
          concepts, including the Virtual DOM and components, then progresses to the setup and debugging of a
          <strong>React Native</strong> project for both iOS and Android. Key architectural topics, such as utilizing
          <strong>Flux and Redux</strong> for state management, are addressed alongside practical guidance for building
          user interfaces with <strong>Flexbox</strong> and animating elements. Further chapters detail how to
          incorporate essential mobile device capabilities, including <strong>GeoLocation and AsyncStorage</strong>, as
          well as techniques for <strong>communicating with servers</strong> and implementing platform-specific code via
          the <strong>Native Bridge</strong>. The guide concludes by covering quality assurance through <strong>Jest and
            Flow</strong> testing and providing the comprehensive steps required for <strong>application
            distribution</strong> on major app stores.
        </p>

        <p>Ahlan! Welcome to the world of React Native. I am here to explain this book to you in a very simple and clear
          way, step by step, just like we do in our Egyptian classrooms—friendly, practical, and easy to understand.</p>
        <p>This book, <em>React Native for Mobile Development</em>, teaches you a powerful skill: how to build
          <strong>fast, native mobile applications</strong> for both <strong>Apple iOS</strong> and <strong>Google
            Android</strong> phones, using your knowledge of <strong>JavaScript</strong>.</p>
        <p>By the end of this journey, you will be able to create an app and publish it to the official App Stores.</p>
        <hr>
        <h2 id="step-by-step-explanation-of-the-book">Step-by-Step Explanation of the Book</h2>
        <h3 id="chapter-1-learning-the-basics-of-react">Chapter 1: Learning the Basics of React</h3>
        <p>Before starting with React Native, we first need to understand <strong>React</strong>. React is a
          <strong>JavaScript library</strong> (a set of helpful code) used for building the parts of an application that
          the user sees (the <strong>User Interface, or UI</strong>).</p>
        <h4 id="important-ideas-in-chapter-1-">Important Ideas in Chapter 1:</h4>
        <ol>
          <li>
            <p><strong>Why React?</strong>
              React helps developers build large apps where data is constantly changing, making things simple and easy
              to maintain. The goal is to &quot;<strong>Learn once, write anywhere</strong>&quot;.</p>
          </li>
          <li>
            <p><strong>Virtual DOM (VDOM)</strong>
              This is a core secret to React’s speed. The browser uses the <strong>DOM</strong> (Document Object Model)
              to show the web page. Changing the real DOM is slow. React keeps a <strong>fast, virtual copy</strong> of
              the DOM (the VDOM).</p>
            <ul>
              <li><strong>Simple Example:</strong> When data changes, React quickly compares the <em>old</em> virtual
                copy with the <em>new</em> virtual copy. It finds <strong>only the small differences</strong> and tells
                the browser to update only those tiny parts. This makes your app feel <strong>blazing fast</strong>.
              </li>
            </ul>
          </li>
          <li>
            <p><strong>One-Way Data Flow</strong>
              This means information in your app flows in only <strong>one direction</strong>.</p>
            <ul>
              <li><strong>Simple Example:</strong> In old systems, if you changed data in one place, it could
                unexpectedly change data in five other places (a messy &quot;spaghetti relationship&quot;). With one-way
                flow, you always know exactly where the data is moving, which makes fixing mistakes easy.</li>
            </ul>
          </li>
          <li>
            <p><strong>Components</strong>
              Components are the <strong>smallest, reusable pieces</strong> that make up your app&#39;s UI (like
              building blocks or widgets). They define how parts of the screen look and act.</p>
          </li>
          <li>
            <p><strong>Properties (Props)</strong>
              <strong>Props</strong> are like fixed settings or arguments that you pass <strong>from a parent component
                down to a child component</strong>.
            </p>
            <ul>
              <li><strong>Simple Example:</strong> If you have a component that shows a message:<ul>
                  <li><strong>Code:</strong> <code>&lt;Message text=&quot;Hello Friend&quot; /&gt;</code></li>
                  <li>The child component uses <code>this.props.text</code> to read the fixed message. <strong>You
                      cannot change props</strong> inside the child component.</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            <p><strong>State</strong>
              <strong>State</strong> is data that a component <strong>keeps track of internally</strong> and can change
              over time. When the state changes, the component automatically updates itself.
            </p>
            <ul>
              <li><strong>Simple Example:</strong> Imagine a text box where you type your name. The text box component
                keeps your input in its state.<ul>
                  <li><strong>Code Idea:</strong> If you type, the function <code>handleChange</code> updates the state:
                    <code>this.setState({ text: e.target.value })</code>.</li>
                  <li><strong>Practical Use:</strong> State is used for internal data that affects the component&#39;s
                    look, while Props are used for initialization data from outside.</li>
                </ul>
              </li>
            </ul>
          </li>
        </ol>
        <hr>
        <h3 id="chapter-2-the-simplest-program-hello-world-with-react-native">Chapter 2: The Simplest Program: Hello
          World with React Native</h3>
        <p>This chapter introduces <strong>React Native</strong> (RN). RN lets you use React and JavaScript to build
          mobile apps that are <strong>fully native</strong> (meaning they use the same building blocks as apps written
          in Swift or Java), so they are very fast.</p>
        <h4 id="important-ideas-in-chapter-2-">Important Ideas in Chapter 2:</h4>
        <ol>
          <li>
            <p><strong>Installation and Setup</strong>
              You need <strong>Node.js</strong> and its package manager <strong>npm</strong> installed. The easiest way
              to start is usually by using <strong>Expo CLI</strong> (a tool built around RN).</p>
          </li>
          <li>
            <p><strong>Expo: Testing Made Easy</strong>
              Expo is an amazing tool chain.</p>
            <ul>
              <li><strong>Simple Example:</strong> You run <code>yarn start</code> and get a <strong>QR code</strong>.
                If you download the Expo app on your phone and scan the code, your app loads instantly, allowing you to
                test on your actual device without installing complicated SDKs.</li>
            </ul>
          </li>
          <li>
            <p><strong>Core Components</strong>
              In RN, you don&#39;t use HTML tags like <code>&lt;div&gt;</code>. Instead, you use RN components that map
              directly to native mobile UI elements:</p>
            <ul>
              <li><strong><code>&lt;View&gt;</code>:</strong> Used primarily for layout and containers (like a
                <code>&lt;div&gt;</code>).</li>
              <li><strong><code>&lt;Text&gt;</code>:</strong> Used only to display text (words).</li>
            </ul>
          </li>
          <li>
            <p><strong>Live Reload</strong>
              This is a miracle feature! When you change the JavaScript code and save the file, the app screen
              <strong>reloads instantly</strong> on the simulator or device, showing your changes. This saves massive
              amounts of time compared to traditional native development, where you must recompile everything.</p>
          </li>
          <li>
            <p><strong>Debugging in Chrome</strong>
              You can debug your RN application using the <strong>Chrome browser</strong>. By installing the
              <strong>React Developer Tools</strong> extension, you can inspect your components and see the exact values
              of their Props and State.</p>
          </li>
        </ol>
        <hr>
        <h3 id="chapter-3-solving-problems-differently-with-flux-and-redux">Chapter 3: Solving Problems Differently with
          Flux and Redux</h3>
        <p>This chapter discusses how to manage data in complex apps using patterns that ensure clarity and
          predictability.</p>
        <h4 id="important-ideas-in-chapter-3-">Important Ideas in Chapter 3:</h4>
        <ol>
          <li>
            <p><strong>The MVC Problem</strong>
              The traditional Model-View-Controller (MVC) pattern gets messy when apps grow because many Models and
              Views interact, creating an &quot;explosion of arrows&quot; (spaghetti code).</p>
          </li>
          <li>
            <p><strong>Flux</strong>
              This is an application architecture that uses a <strong>unidirectional (one-way) data flow</strong> to
              keep things simple.</p>
            <ul>
              <li><strong>Parts of Flux:</strong> <strong>Dispatcher</strong> (traffic cop), <strong>Stores</strong>
                (data storage/logic), and <strong>Views</strong> (React components).</li>
            </ul>
          </li>
          <li>
            <p><strong>Redux: Predictable State Management</strong>
              Redux is the most popular solution, built on the idea of functional programming. It provides a
              <strong>single, predictable container</strong> for your application&#39;s state.</p>
            <ul>
              <li><strong>Action:</strong> A simple object that describes <strong>what happened</strong> (e.g.,
                <code>type: &#39;ADD_TODO&#39;</code>).</li>
              <li><strong>Reducer:</strong> A <strong>pure function</strong> that takes the old state and an action, and
                returns the <strong>new state</strong>.</li>
              <li>
                <p><strong>Store:</strong> The single place that <strong>holds all the data</strong> (state) for the
                  whole application.</p>
              </li>
              <li>
                <p><strong>Simple Example (Redux Data Flow):</strong></p>
                <ol>
                  <li><strong>User interacts</strong> (clicks &quot;Add&quot;) -&gt; Sends an <strong>Action</strong>
                    (ADD_ITEM).</li>
                  <li>The Action goes to the <strong>Store</strong>.</li>
                  <li>The Store uses the <strong>Reducer</strong> to figure out <em>how</em> the state should change (it
                    adds the new item to the list).</li>
                  <li>The Store holds the new state, and the View updates automatically.</li>
                </ol>
              </li>
              <li>
                <p><strong>Simple Code Idea (Dispatching an Action):</strong>
                  To send an action to the Store, you use the <code>dispatch</code> function:</p>
                <ul>
                  <li><code>this.props.dispatch(addTodo(text))</code></li>
                </ul>
              </li>
            </ul>
          </li>
        </ol>
        <hr>
        <h3 id="chapter-4-canvas-brush-and-paint-working-with-the-user-interface">Chapter 4: Canvas, Brush, and Paint:
          Working with the User Interface</h3>
        <p>This chapter focuses on making your app look great and organizing the screens.</p>
        <h4 id="important-ideas-in-chapter-4-">Important Ideas in Chapter 4:</h4>
        <ol>
          <li>
            <p><strong>React Navigation</strong>
              This library manages how users <strong>move between different screens</strong> in your app (like the
              drill-down navigation in iOS/Android).</p>
            <ul>
              <li><strong>Simple Example:</strong> You define a stack of screens:<ul>
                  <li><strong>Code Idea:</strong>
                    <code>createStackNavigator({ Home: { screen: HomeScreen }, About: { screen: AboutScreen }})</code>.
                  </li>
                  <li>To move from Home to About, you use a special function provided to the component:
                    <code>this.props.navigation.navigate(&#39;About&#39;)</code>.</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            <p><strong>Flexbox</strong>
              This is the layout system RN uses for styling components. It helps your UI elements <strong>automatically
                adjust</strong> to different screen sizes and device rotations (landscape or portrait).</p>
            <ul>
              <li><strong>Simple Example (Flex Ratio):</strong> If you have a container with two parts, and you give
                them <code>flex: 2</code> and <code>flex: 1</code>, the screen will be divided into two sections in a
                <strong>2:1 size ratio</strong>.</li>
            </ul>
          </li>
          <li>
            <p><strong>TouchableHighlight</strong>
              If you want an image or a piece of text to be clickable, you wrap it in a <code>TouchableHighlight</code>
              component.</p>
            <ul>
              <li><strong>Simple Code Idea:</strong>
                <ul>
                  <li>
                    <code>&lt;TouchableHighlight onPress={this.doSomething}&gt; &lt;Text&gt;Click Me&lt;/Text&gt; &lt;/TouchableHighlight&gt;</code>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            <p><strong>FlatList (For Long Lists)</strong>
              When showing a long list of data (like a list of houses or friends), use
              <strong><code>&lt;FlatList&gt;</code></strong>. It is very efficient because it only renders items
              <strong>just before they appear on the screen</strong> (this is called lazy rendering), saving memory.</p>
            <ul>
              <li><strong>Practical Example:</strong> If you are listing 1,000 houses, <code>FlatList</code> only
                creates the first 10, making the app start fast.</li>
            </ul>
          </li>
          <li>
            <p><strong>Animations</strong>
              You use the <code>Animated</code> API to create smooth visual effects.</p>
            <ul>
              <li><strong>Simple Code Idea (Fade In):</strong> To make a picture slowly appear (fade in) over 4 seconds:
                <ul>
                  <li>You use <code>Animated.timing()</code> to change the component’s <code>opacity</code> (how visible
                    it is) from 0 (invisible) to 1 (fully visible) over a <code>duration: 4000</code> milliseconds.</li>
                </ul>
              </li>
            </ul>
          </li>
        </ol>
        <hr>
        <h3 id="chapter-5-exploring-device-capabilities">Chapter 5: Exploring Device Capabilities</h3>
        <p>This chapter shows how to use the special built-in hardware and software features of the mobile device.</p>
        <h4 id="important-ideas-in-chapter-5-">Important Ideas in Chapter 5:</h4>
        <ol>
          <li>
            <p><strong>MapView and GeoLocation (Location Services)</strong>
              You use <strong><code>&lt;MapView&gt;</code></strong> to show maps.</p>
            <ul>
              <li><strong>Practical Example:</strong> Use <code>navigator.geolocation.watchPosition</code> to
                <strong>continuously track the user’s location</strong> as they move, updating the map in real time. You
                can also add markers (annotations) to point out specific places.</li>
            </ul>
          </li>
          <li>
            <p><strong>AsyncStorage (Local Storage)</strong>
              This is a simple system to <strong>save small bits of data permanently</strong> (key/value pairs) on the
              user&#39;s phone. This data stays even if the app is closed.</p>
            <ul>
              <li><strong>Simple Code Idea:</strong>
                <ul>
                  <li><strong>Save:</strong> <code>AsyncStorage.setItem(&#39;MyKey&#39;, &#39;MyValue&#39;)</code></li>
                  <li><strong>Get:</strong> <code>AsyncStorage.getItem(&#39;MyKey&#39;)</code></li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            <p><strong>Native Alert</strong>
              Used to show standard mobile <strong>pop-up alerts</strong> (dialog boxes) to the user.</p>
            <ul>
              <li><strong>Simple Code Idea:</strong>
                <ul>
                  <li>
                    <code>Alert.alert(&#39;Title&#39;, &#39;Message&#39;, [{ text: &#39;OK&#39;, onPress: () =&gt; console.log(&#39;OK pressed&#39;) }])</code>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            <p><strong>Deep Linking</strong>
              This technique allows a <strong>special link</strong> (from an email or website) to <strong>open your
                application directly</strong> to a specific internal screen.</p>
            <ul>
              <li><strong>Simple Example:</strong> Clicking a link like <code>myapp://article/4</code> automatically
                opens your app and shows Article number 4.</li>
            </ul>
          </li>
        </ol>
        <hr>
        <h3 id="chapter-6-communicating-with-servers">Chapter 6: Communicating with Servers</h3>
        <p>This is essential for real-world applications: getting and saving data from the internet.</p>
        <h4 id="important-ideas-in-chapter-6-">Important Ideas in Chapter 6:</h4>
        <ol>
          <li>
            <p><strong>Fetch API</strong>
              This is the popular and modern way to make network requests. <code>Fetch</code> returns a
              <strong>Promise</strong>, which means the function asks for the data and then lets the rest of your code
              run. When the data finally arrives, the promise is fulfilled.</p>
          </li>
          <li>
            <p><strong>Getting Data (GET Request)</strong>
              You typically use <code>fetch</code> inside the <code>componentDidMount()</code> function so the data
              loads when the screen appears for the first time.</p>
            <ul>
              <li><strong>Simple Code Idea:</strong>
                <ul>
                  <li>
                    <code>fetch(&quot;your_server_url&quot;) .then(response =&gt; response.json()) .then(data =&gt; { this.setState({ dataSource: data }) })</code>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            <p><strong>Saving Data (POST Request)</strong>
              You use <code>fetch</code> and specify the method as <code>&#39;POST&#39;</code>, and include the data you
              want to save in the <code>body</code>.</p>
            <ul>
              <li><strong>Simple Code Idea:</strong>
                <ul>
                  <li>
                    <code>fetch(&#39;server_url/properties&#39;, { method: &#39;POST&#39;, body: JSON.stringify({ name: &#39;New House&#39; }) })</code>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ol>
        <hr>
        <h3 id="chapter-7-native-bridging-in-react-native">Chapter 7: Native Bridging in React Native</h3>
        <p>This is a bit more advanced! This technique is used when you need to access a feature of the iOS or Android
          system that doesn&#39;t have a JavaScript equivalent yet, or if you want to reuse existing native code (Swift
          or Java).</p>
        <h4 id="important-ideas-in-chapter-7-">Important Ideas in Chapter 7:</h4>
        <ol>
          <li>
            <p><strong>Native Bridge</strong>
              This is the communication system that connects the JavaScript world (where your RN code lives) with the
              Native world (Swift for iOS, Java/Kotlin for Android).</p>
          </li>
          <li>
            <p><strong>Accessing Native Code</strong>
              You write a class in the native language and expose its functions to JavaScript. In JavaScript, you access
              it using <code>NativeModules</code>.</p>
            <ul>
              <li><strong>Simple Code Idea (Calling Native):</strong>
                <ul>
                  <li><code>NativeModules.Counter.increment()</code></li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            <p><strong>Callbacks (Getting Results Back)</strong>
              The Native Bridge is <strong>asynchronous</strong> (it takes time), so to get a result from the Native
              code back into JavaScript, you must use a <strong>callback function</strong>.</p>
            <ul>
              <li><strong>Simple Code Idea:</strong>
                <ul>
                  <li>
                    <code>NativeModules.Counter.getCount( (error, count)=&gt;{ this.setState({ count: count}); })</code>
                  </li>
                  <li><em>Explanation:</em> You give the Native code a function (the callback) to run <em>after</em> it
                    finishes calculating the count.</li>
                </ul>
              </li>
            </ul>
          </li>
        </ol>
        <hr>
        <h3 id="chapter-8-testing">Chapter 8: Testing</h3>
        <p>Testing is your responsibility to ensure your app works correctly.</p>
        <h4 id="important-ideas-in-chapter-8-">Important Ideas in Chapter 8:</h4>
        <ol>
          <li>
            <p><strong>Flow (Static Type Checker)</strong>
              Flow is a tool that <strong>checks your JavaScript code for errors before you even run it</strong>. It
              helps you find problems early and code faster.</p>
          </li>
          <li>
            <p><strong>Jest</strong>
              Jest is the recommended and powerful tool for <strong>unit testing</strong> (testing small parts of your
              code).</p>
          </li>
          <li>
            <p><strong>Snapshot Testing</strong>
              This is a super helpful feature of Jest for the UI.</p>
            <ul>
              <li><strong>Simple Example:</strong> You take a &quot;<strong>picture</strong>&quot; (snapshot) of your
                component&#39;s code structure and save it. If you later change the styling or content, Jest compares
                the new picture with the old one. If they don&#39;t match, the test <strong>fails</strong>, warning you
                about unexpected changes in the UI.</li>
              <li><strong>Simple Code Idea:</strong> <code>expect(tree).toMatchSnapshot()</code></li>
            </ul>
          </li>
        </ol>
        <hr>
        <h3 id="chapter-9-getting-ready-for-the-world-publishing-">Chapter 9: Getting Ready for the World (Publishing)
        </h3>
        <p>This chapter explains how to create the final application file (the &quot;build&quot;) and upload it to the
          stores.</p>
        <h4 id="important-ideas-in-chapter-9-">Important Ideas in Chapter 9:</h4>
        <ol>
          <li>
            <p><strong>Developer Accounts</strong></p>
            <ul>
              <li><strong>iOS:</strong> You need a paid <strong>Apple Developer Account</strong> (around $99/year) to
                create builds and publish.</li>
              <li><strong>Android:</strong> You need a <strong>Google Play Console</strong> account (one-time $25 fee)
                only when you are ready to publish.</li>
            </ul>
          </li>
          <li>
            <p><strong>iOS Build Process (.ipa)</strong>
              This involves using <strong>Xcode</strong> (on a Mac) to set up various certificates (proof of identity),
              App IDs (unique app name), and Provisioning Profiles. You use the &quot;Archive&quot; command in Xcode to
              create the final <code>.ipa</code> file, which is then uploaded to <strong>App Store Connect</strong>.</p>
          </li>
          <li>
            <p><strong>Android Build Process (.apk)</strong>
              Android builds are signed with a certificate generated using the <strong>Java Development Kit
                (JDK)</strong>. The final package file (<code>.apk</code>) is generated using Gradle and can be
              submitted to the Google Play Store.</p>
          </li>
          <li>
            <p><strong>Beta Testing with TestFlight</strong>
              Before releasing to the public, you need testing. <strong>TestFlight</strong> (provided by Apple) allows
              you to invite up to 10,000 testers to download and test your app builds easily on their iOS devices.</p>
          </li>
        </ol>
        <hr>
        <h3 id="chapter-10-the-ecosystem-extending-react-native">Chapter 10: The Ecosystem: Extending React Native</h3>
        <p>This final chapter gives you advice on tools to speed up your work and where to find help.</p>
        <h4 id="important-ideas-in-chapter-10-">Important Ideas in Chapter 10:</h4>
        <ol>
          <li>
            <p><strong>Popular Libraries</strong>
              The community has created thousands of helpful tools. Examples include:</p>
            <ul>
              <li><strong>UI/Design:</strong> <code>react-native-vector-icons</code> (for logos and buttons).</li>
              <li><strong>Forms:</strong> <code>Formik</code> or <code>Redux-form</code> (to manage complex form data).
              </li>
              <li><strong>Networking:</strong> <code>Axios</code> (makes server requests easier than plain
                <code>fetch</code>).</li>
              <li><strong>Utilities:</strong> <code>Lodash</code> (provides many general helper functions for
                JavaScript).</li>
            </ul>
          </li>
          <li>
            <p><strong>Where to Get Help</strong></p>
            <ul>
              <li><strong>React Native Repository:</strong> For reporting bugs directly to the team.</li>
              <li><strong>Stack Overflow:</strong> A huge Q&amp;A site where other developers answer questions quickly.
              </li>
              <li><strong>Communities:</strong> Online groups like React Discord or Facebook groups to connect with
                fellow developers.</li>
            </ul>
          </li>
        </ol>
        <h2 id="-">---</h2>
        <h2 id="summary-and-practical-guide">Summary and Practical Guide</h2>
        <h3 id="short-summary-for-each-chapter">Short Summary for Each Chapter</h3>
        <table>
          <thead>
            <tr>
              <th style="text-align:left">Chapter</th>
              <th style="text-align:left">Title</th>
              <th style="text-align:left">Summary</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="text-align:left"><strong>1</strong></td>
              <td style="text-align:left">Learning the Basics: A Whistle-Stop Tour of React</td>
              <td style="text-align:left">Focuses on core React concepts like <strong>Virtual DOM</strong> (for speed),
                <strong>one-way data flow</strong> (for clarity), and <strong>Components</strong> that manage data using
                <strong>Props</strong> (fixed data) and <strong>State</strong> (changing data).</td>
            </tr>
            <tr>
              <td style="text-align:left"><strong>2</strong></td>
              <td style="text-align:left">The Simplest Program: Hello World with React Native</td>
              <td style="text-align:left">Introduces React Native as a platform for fast native apps. Covers
                installation, using <strong>Expo</strong> for easy testing, the basic components
                (<code>&lt;View&gt;</code>, <code>&lt;Text&gt;</code>), and <strong>Live Reload</strong>.</td>
            </tr>
            <tr>
              <td style="text-align:left"><strong>3</strong></td>
              <td style="text-align:left">Solving Problems Differently with Flux and Redux</td>
              <td style="text-align:left">Explains how to manage complex application data (<strong>state</strong>) using
                the <strong>Redux</strong> pattern, which relies on strict, predictable flow between
                <strong>Actions</strong>, <strong>Reducers</strong>, and the <strong>Store</strong>.</td>
            </tr>
            <tr>
              <td style="text-align:left"><strong>4</strong></td>
              <td style="text-align:left">Canvas, Brush, and Paint: Working with the UI</td>
              <td style="text-align:left">Teaches UI design: moving between screens using <strong>React
                  Navigation</strong>, laying out components efficiently with <strong>Flexbox</strong> (using size
                ratios), creating clickable areas with <strong>TouchableHighlight</strong>, and using
                <strong>FlatList</strong> for long data lists.</td>
            </tr>
            <tr>
              <td style="text-align:left"><strong>5</strong></td>
              <td style="text-align:left">Exploring Device Capabilities</td>
              <td style="text-align:left">How to use built-in mobile features like maps (<strong>MapView</strong>),
                location tracking (<strong>GeoLocation</strong>), local phone storage (<strong>AsyncStorage</strong>),
                pop-up messages (<strong>Native Alert</strong>), and special links (<strong>Deep Linking</strong>).</td>
            </tr>
            <tr>
              <td style="text-align:left"><strong>6</strong></td>
              <td style="text-align:left">Communicating with Servers</td>
              <td style="text-align:left">Essential networking skills using the <strong>Fetch API</strong> to
                <strong>GET</strong> (read) and <strong>POST</strong> (save) data to a back-end server.</td>
            </tr>
            <tr>
              <td style="text-align:left"><strong>7</strong></td>
              <td style="text-align:left">Native Bridging in React Native</td>
              <td style="text-align:left">Advanced topic showing how the <strong>Native Bridge</strong> allows your
                JavaScript code to call specialized functions written in the native platform languages (Swift/Java)
                using <strong>callbacks</strong>.</td>
            </tr>
            <tr>
              <td style="text-align:left"><strong>8</strong></td>
              <td style="text-align:left">Testing</td>
              <td style="text-align:left">Your responsibility to ensure code quality using tools like
                <strong>Flow</strong> (pre-run error checking) and <strong>Jest</strong> (for testing), including
                <strong>Snapshot Testing</strong> to monitor unexpected UI changes.</td>
            </tr>
            <tr>
              <td style="text-align:left"><strong>9</strong></td>
              <td style="text-align:left">Getting Ready for the World</td>
              <td style="text-align:left">How to prepare the final app package (build) for distribution, including
                signing apps for iOS (using <strong>Xcode</strong> and <strong>App Store Connect</strong>) and Android,
                and using <strong>TestFlight</strong> for testing.</td>
            </tr>
            <tr>
              <td style="text-align:left"><strong>10</strong></td>
              <td style="text-align:left">The Ecosystem: Extending React Native</td>
              <td style="text-align:left">A guide to useful community-made libraries (e.g., for forms, testing, or
                network requests) and the best places (like <strong>Stack Overflow</strong>) to get help.</td>
            </tr>
          </tbody>
        </table>
        <hr>
        <h3 id="main-key-ideas-of-the-book">Main Key Ideas of the Book</h3>
        <p>The central goals and concepts of the book are:</p>
        <ol>
          <li><strong>Cross-Platform Native Development:</strong> Use JavaScript (React) to build high-performance
            applications for both iOS and Android from a single codebase.</li>
          <li><strong>Performance through VDOM:</strong> React achieves speed by minimizing direct updates to the UI
            using the <strong>Virtual DOM</strong> and a fast diffing algorithm.</li>
          <li><strong>Component Architecture:</strong> Applications are built from small, reusable pieces (Components)
            that manage their own internal data (<strong>State</strong>) or receive fixed data (<strong>Props</strong>).
          </li>
          <li><strong>Predictable State Management (Redux):</strong> Using unidirectional data flow to ensure complex
            data changes are easy to track and debug.</li>
          <li><strong>Flexbox Layout:</strong> Relying on flexible layout models to handle diverse screen sizes and
            orientations automatically.</li>
          <li><strong>Harnessing Native Capabilities:</strong> Integrating powerful device features like GPS, local
            storage, and alerts.</li>
          <li><strong>Bridging the Gap:</strong> Utilizing the Native Bridge to access specific platform APIs when
            necessary.</li>
          <li><strong>Quality through Testing:</strong> Implementing tools like Flow and Jest to ensure code quality and
            UI stability.</li>
        </ol>
        <hr>
        <h3 id="practical-examples-i-can-use-right-away">Practical Examples I Can Use Right Away</h3>
        <p>Here are some immediate tasks you can perform when starting a React Native project:</p>
        <table>
          <thead>
            <tr>
              <th style="text-align:left">Task</th>
              <th style="text-align:left">Component/Concept Used</th>
              <th style="text-align:left">Simple Code Example/Idea</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="text-align:left"><strong>Make an element clickable</strong></td>
              <td style="text-align:left"><code>TouchableHighlight</code></td>
              <td style="text-align:left">Wrap an image or text in
                <code>&lt;TouchableHighlight onPress={yourFunction}&gt;</code>.</td>
            </tr>
            <tr>
              <td style="text-align:left"><strong>Save data locally</strong></td>
              <td style="text-align:left"><code>AsyncStorage</code></td>
              <td style="text-align:left"><code>AsyncStorage.setItem(&#39;username&#39;, &#39;Ahmed&#39;)</code> to save
                data permanently.</td>
            </tr>
            <tr>
              <td style="text-align:left"><strong>Display a list of items</strong></td>
              <td style="text-align:left"><code>FlatList</code></td>
              <td style="text-align:left">Use <code>&lt;FlatList data={myArrayOfData} renderItem={...} /&gt;</code>.
                Remember <code>FlatList</code> is best for long, efficient scrolling.</td>
            </tr>
            <tr>
              <td style="text-align:left"><strong>Show a critical message</strong></td>
              <td style="text-align:left"><code>Alert</code></td>
              <td style="text-align:left"><code>Alert.alert(&#39;Error&#39;, &#39;Something went wrong!&#39;)</code> to
                show a native dialog box.</td>
            </tr>
            <tr>
              <td style="text-align:left"><strong>Update internal component data</strong></td>
              <td style="text-align:left"><code>State</code></td>
              <td style="text-align:left">Call <code>this.setState({ count: this.state.count + 1 })</code> to trigger an
                update and re-render.</td>
            </tr>
            <tr>
              <td style="text-align:left"><strong>Get initial data from a server</strong></td>
              <td style="text-align:left"><code>Fetch</code> &amp; <code>componentDidMount</code></td>
              <td style="text-align:left">Call <code>fetch(&#39;my_api_url&#39;)</code> inside
                <code>componentDidMount()</code> so data loads when the screen opens.</td>
            </tr>
          </tbody>
        </table>
        <hr>
        <h3 id="simple-tips-to-help-me-apply-what-i-learned">Simple Tips to Help Me Apply What I Learned</h3>
        <ol>
          <li><strong>Embrace the &quot;Learn Once, Write Anywhere&quot; Mindset:</strong> Focus on understanding React
            principles (components, state, props) first, as these are the same whether you build for the web or for
            mobile.</li>
          <li><strong>Use Components for Everything:</strong> Think of your screen in terms of small, reusable,
            independent components. This makes testing and maintenance much simpler.</li>
          <li><strong>Keep Data Flow Unidirectional:</strong> If you are using Redux (Chapter 3), always ensure data
            moves clearly from Action to Reducer to Store. Never try to change the state directly outside of the
            Reducer.</li>
          <li><strong>Trust Flexbox:</strong> Don&#39;t fight the layout system! Practice using <code>flex</code>,
            <code>flexDirection</code>, and alignment properties (Chapter 4) to ensure your app looks great on different
            phone sizes.</li>
          <li><strong>Test Responsibly:</strong> Use Flow (Chapter 8) to check your code before you run it, saving you
            debugging time. When updating UI components, use Jest Snapshot testing to make sure you didn&#39;t
            accidentally break anything.</li>
          <li><strong>Stay Connected:</strong> React Native is fast-moving. Use the community resources like Stack
            Overflow (Chapter 10) to ask questions and stay updated on the latest changes.</li>
        </ol>





      </div>
    </div>

  </div>


  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" //
    integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+Y2XIdI6kB1jRVVbR4D9M1zYjFq2D" //
    crossorigin="anonymous"></script>

  <script src="../script.js"> </script>


</body>

</html>