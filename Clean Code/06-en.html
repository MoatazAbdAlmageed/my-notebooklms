<!DOCTYPE html>
<html data-bs-theme="dark" dir="ltr">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>06</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

</head>

<body>
    <div class="container">
        <div class="row">
            <div class="col-12">


                <p>This chapter (Chapter 6: Objects and Data Structures) addresses the fundamental difference between
                    objects (Object-Oriented programming) and data structures (procedural programming) and the
                    importance of maintaining data abstraction.</p>
                <h2 id="1-data-abstraction">1. Data Abstraction</h2>
                <p>The chapter begins by emphasizing the necessity of keeping variables <strong>private</strong> to
                    retain the freedom to change their type or implementation. However, many developers undermine this
                    principle by automatically adding simple getters and setters, which exposes the internal
                    implementation.</p>
                <p><strong>Hiding implementation is about abstractions</strong>. A clean class exposes <strong>abstract
                        interfaces</strong> that enable users to manipulate the essence of the data without needing to
                    know its internal form (such as whether coordinates are stored in rectangular or polar format). The
                    <strong>worst option</strong> is to thoughtlessly add getters and setters.
                </p>
                <h2 id="2-data-object-anti-symmetry">2. Data/Object Anti-Symmetry</h2>
                <p>Objects and data structures are defined as &quot;virtual opposites&quot;:</p>
                <table>
                    <thead>
                        <tr>
                            <th style="text-align:left">Type</th>
                            <th style="text-align:left">Definition</th>
                            <th style="text-align:left">Consequences of Change</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="text-align:left"><strong>Objects (OO Code)</strong></td>
                            <td style="text-align:left">They <strong>hide their data</strong> behind abstractions and
                                <strong>expose functions</strong> (or behavior) that operate on that data.
                            </td>
                            <td style="text-align:left">It is <strong>easy to add new classes</strong> (types) without
                                changing existing functions. It is <strong>hard to add new functions</strong> because
                                all existing classes must be changed.</td>
                        </tr>
                        <tr>
                            <td style="text-align:left"><strong>Data Structures (Procedural Code)</strong></td>
                            <td style="text-align:left">They <strong>expose their data</strong> and have no meaningful
                                functions.</td>
                            <td style="text-align:left">It is <strong>easy to add new functions</strong> without
                                changing the existing data structures. It is <strong>hard to add new data
                                    structures</strong> because all existing functions must be changed.</td>
                        </tr>
                    </tbody>
                </table>
                <p>This dichotomy means that certain designs (like calculating the area of various shapes) that are easy
                    in a procedural style become difficult in an OO style, and vice versa.</p>
                <h2 id="3-the-law-of-demeter-lod-">3. The Law of Demeter (LoD)</h2>
                <p>The Law of Demeter is a well-known heuristic stating that a module should not know about the
                    &quot;innards&quot; of the objects it manipulates. This means an object should avoid exposing its
                    internal structure through accessors.</p>
                <p>More precisely, a method <strong>f</strong> of a class <strong>C</strong> should only call methods
                    belonging to:</p>
                <ol>
                    <li>The object <strong>C</strong> itself.</li>
                    <li>An object created by <strong>f</strong>.</li>
                    <li>An object passed as an argument to <strong>f</strong>.</li>
                    <li>An object held in an instance variable of <strong>C</strong>.</li>
                </ol>
                <p>Violations often occur in long chains of calls, referred to as <strong>&quot;Train
                        Wrecks&quot;</strong> (e.g., <code>ctxt.getOptions().getScratchDir().getAbsolutePath()</code>),
                    which expose the internal structure of multiple objects.</p>
                <p>The Law of Demeter <strong>applies to objects</strong> because they are designed to hide structure,
                    but <strong>does not apply to data structures</strong> because they are meant to expose their
                    internal structure.</p>
                <h2 id="4-hybrids-and-dtos">4. Hybrids and DTOs</h2>
                <p>Mixing these two concepts can lead to problematic structures:</p>
                <ul>
                    <li><strong>Hybrids:</strong> These are &quot;unfortunate hybrid structures&quot; that are half
                        object and half data structure. They contain meaningful functions but also expose their
                        variables (either publicly or via public accessors/mutators), tempting external functions to
                        treat them as procedural data structures. Such hybrids are the <strong>worst of both
                            worlds</strong> as they make it hard to add both new functions and new data structures.</li>
                    <li><strong>Data Transfer Objects (DTOs):</strong> These are the quintessential form of a data
                        structure, typically a class with <strong>public variables and no functions</strong>. They are
                        often used for communicating with databases or parsing messages.</li>
                    <li><strong>Beans:</strong> A common form of DTO in Java where variables are private but accessed
                        via <code>getters</code> and <code>setters</code>. The resulting quasi-encapsulation usually
                        offers no significant benefit.</li>
                    <li><strong>Active Record:</strong> Special DTOs that typically mirror database tables and include
                        navigational methods (like <code>save</code> and <code>find</code>) alongside their public data
                        members. Developers should avoid treating these active records as full objects by adding
                        business rule methods, as this creates an awkward hybrid.</li>
                </ul>

            </div>
        </div>

    </div>


    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+Y2XIdI6kB1jRVVbR4D9M1zYjFq2D"
        crossorigin="anonymous"></script>


    <script src="../script.js"> </script>


</body>

</html>