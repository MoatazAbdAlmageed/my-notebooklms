<!DOCTYPE html>
<html data-bs-theme="dark" lang="en" dir="ltr">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title></title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

    <link rel="stylesheet" href="../style.css">
</head>

<body>
    <div class="container">
        <div class="row">
            <div class="col-12">

                <p>Ahlan! Welcome to Chapter 5: <strong>Vuex and Servers</strong>. This chapter is where your
                    application becomes truly powerful because you learn how to save your data permanently, even if the
                    user closes their browser and comes back later!</p>
                <p>In Chapter 4, we learned how Vuex manages shared data (the State) inside your application. But if you
                    refreshed the page, that data would disappear. In this chapter, we use Vuex to build a professional
                    <strong>Shopping Cart App</strong> that talks to a separate server (a permanent filing cabinet) to
                    save all changes.</p>
                <hr>
                <h3 id="step-1-client-and-server-synchronization-the-goal-">Step 1: Client and Server Synchronization
                    (The Goal)</h3>
                <p><strong>Your application now has two places where important data lives.</strong></p>
                <ol>
                    <li>The <strong>Vuex Store</strong> (Client State): This is the fast, temporary copy of the data
                        used to instantly update the user&#39;s screen.</li>
                    <li>The <strong>Server</strong> (Permanent State): This is the permanent database where data lives
                        even if the computer shuts down.</li>
                </ol>
                <p><strong>The most important job is to keep these two places exactly the same (in sync).</strong>
                    When the application first loads, it must ask the server for all the data to fill the Vuex store.
                    When the user makes a change (like adding an item), the application must tell the server to save the
                    change, and then update the Vuex store with the result. This process is called
                    <strong>Persistence</strong>.</p>
                <ul>
                    <li><strong>Analogy:</strong> Think of the Vuex Store as your local notes (fast access, easy to
                        read), and the Server as the official, permanent filing cabinet. Every time you make a change to
                        your notes, you must send a request to the filing cabinet to make the official update, and then
                        ensure your notes match the cabinet&#39;s official record.</li>
                </ul>
                <h3 id="step-2-organizing-the-vuex-store-with-modules">Step 2: Organizing the Vuex Store with Modules
                </h3>
                <p><strong>When your application grows, you must keep the Vuex store organized.</strong>
                    If your application has many different parts (like products, user accounts, and cart items), putting
                    all the State, Mutations, and Actions into one giant file gets confusing.</p>
                <p><strong>Vuex Modules break the store into smaller, specific sections.</strong>
                    Modules allow you to separate the application store into manageable fragments. We create a module
                    for each main function of the app.</p>
                <ul>
                    <li><strong>Practical Example (Shopping Cart App):</strong>
                        <ol>
                            <li><strong>Product Module:</strong> Handles everything related to reading the list of
                                available products.</li>
                            <li><strong>Cart Module:</strong> Handles everything related to the customer&#39;s cart
                                (adding, removing, calculating totals).</li>
                        </ol>
                    </li>
                </ul>
                <p>Modules are then assembled inside the main Vuex Store using the <code>modules</code> property.</p>
                <h3 id="step-3-the-action-s-new-role-handling-slow-network-tasks-">Step 3: The Action&#39;s New Role
                    (Handling Slow Network Tasks)</h3>
                <p><strong>When dealing with a server, the Vuex Action becomes crucial.</strong>
                    Remember from Chapter 4 that <strong>Mutations must be fast and synchronous (happen
                        instantly)</strong>. Talking to a server is <strong>asynchronous</strong> (it takes time—maybe
                    milliseconds, maybe seconds).</p>
                <p><strong>The Action is the only place allowed to handle slow tasks.</strong></p>
                <ul>
                    <li>
                        <p><strong>What Action does now:</strong></p>
                        <ol>
                            <li>A component <strong>dispatches</strong> an action (e.g., &quot;Add product to
                                cart&quot;).</li>
                            <li>The Action sends the request to the server using an AJAX tool like
                                <strong>axios</strong>.</li>
                            <li>The Action waits for the server&#39;s reply.</li>
                            <li>Once the server confirms the change (usually by returning the <em>new, updated
                                    list</em>), the Action finally <strong>commits</strong> the Mutation.</li>
                        </ol>
                    </li>
                    <li>
                        <p><strong>The Action is asynchronous and must use Promises.</strong> Since server communication
                            is slow, Actions must return a Promise to let the component know when the task is truly
                            finished.</p>
                    </li>
                </ul>
                <p><strong>Code Example (Defining the Action):</strong></p>
                <pre><code class="lang-javascript"><span class="hljs-comment">// Inside the Cart Module Actions</span>
<span class="hljs-keyword">const</span> actions = {
  addCartItem ({ commit }, cartItem) {
    <span class="hljs-comment">// axios handles the slow request and returns a Promise</span>
    <span class="hljs-keyword">return</span> axios.post(<span class="hljs-string">'/api/cart'</span>, cartItem)
      .then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
        <span class="hljs-comment">// SUCCESS: Now commit the mutation with the fresh data from the server</span>
        commit(<span class="hljs-string">'UPDATE_CART_ITEMS'</span>, response.data)
      });
  },
  <span class="hljs-comment">// ... other actions</span>
}
</code></pre>
                <ul>
                    <li><code>axios.post(&#39;/api/cart&#39;, cartItem)</code>: This makes the asynchronous call to the
                        server, sending the item data.</li>
                    <li><code>.then((response) =&gt; {...})</code>: This code waits until the server replies
                        successfully.</li>
                    <li><code>commit(&#39;UPDATE_CART_ITEMS&#39;, response.data)</code>: The Mutation is committed
                        <em>only</em> here, and the payload (<code>response.data</code>) contains the <strong>updated
                            list of items directly from the server</strong>.</li>
                </ul>
                <h3 id="step-4-fetching-initial-data-read-operation-">Step 4: Fetching Initial Data (Read Operation)
                </h3>
                <p><strong>When the app starts, it needs to fill the Vuex store from the server.</strong>
                    This is a <strong>read operation</strong>. It happens when the main application component loads
                    (often in the <code>created()</code> lifecycle hook).</p>
                <ul>
                    <li><strong>Component Action:</strong> The component dispatches an Action to get the data.</li>
                    <li><strong>Store Action (<code>getProductItems</code>):</strong> The Action calls the server using
                        <code>axios.get(&#39;/api/products&#39;)</code>.</li>
                    <li><strong>Store Mutation (<code>UPDATE_PRODUCT_ITEMS</code>):</strong> When the data arrives, the
                        Action commits a Mutation to replace the empty local State array with the new data.</li>
                </ul>
                <p><strong>Code Example (Component calling the Action):</strong></p>
                <pre><code class="lang-javascript">// Inside ProductList.vue <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-comment">// ...</span>
  created() {
    <span class="hljs-keyword">this</span>.$store.dispatch(<span class="hljs-string">'getProductItems'</span>); <span class="hljs-comment">// Ask the store to fetch the products</span>
  }
}</span>
</code></pre>
                <ul>
                    <li><code>this.$store.dispatch(&#39;getProductItems&#39;)</code>: This asks the store to start the
                        slow process of talking to the server.</li>
                </ul>
                <h3 id="step-5-using-mapgetters-reading-data-from-modules-">Step 5: Using MapGetters (Reading Data from
                    Modules)</h3>
                <p><strong>After the Action updates the State, components need a simple way to read that data.</strong>
                    Because the data is now organized in modules, you can use the <code>mapGetters</code> helper
                    function provided by Vuex to easily map store getters to computed properties in your component.</p>
                <ul>
                    <li><strong>Complex Getters:</strong> Getters are also used for complex calculations needed across
                        the app, like totaling the price of all items in the cart.</li>
                </ul>
                <p><strong>Code Example (Calculating Cart Total):</strong></p>
                <pre><code class="lang-javascript">// Inside the Cart Module Getters
cartTotal: <span class="hljs-keyword">state</span> =&gt; {
  return <span class="hljs-keyword">state</span>.cartItems.reduce((acc, cartItem) =&gt; {
    // Calculate total price using reduce
    return (cartItem.quantity * cartItem.price) + acc;
  }, <span class="hljs-number">0</span>).<span class="hljs-keyword">to</span>Fixed(<span class="hljs-number">2</span>);
}
</code></pre>
                <ul>
                    <li><code>reduce</code>: This is a JavaScript method that takes the list of items
                        (<code>cartItems</code>) and calculates a single total value (like the sum of all prices).</li>
                </ul>
                <p><strong>Code Example (Mapping the Getter to a Component):</strong></p>
                <pre><code class="lang-javascript">// Inside CartList.vue <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { mapGetters } <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-comment">// ...</span>
  computed: {
    ...mapGetters([<span class="hljs-string">'cartItems'</span>, <span class="hljs-string">'cartTotal'</span>]) <span class="hljs-comment">// Now 'this.cartTotal' works!</span>
  }
}</span>
</code></pre>
                <ul>
                    <li><code>...mapGetters([&#39;cartTotal&#39;])</code>: This makes the store&#39;s calculated
                        <code>cartTotal</code> available to the component instantly as <code>this.cartTotal</code>.</li>
                </ul>
                <hr>
                <h3 id="summary-and-practical-advice">Summary and Practical Advice</h3>
                <h4 id="short-chapter-summary">Short Chapter Summary</h4>
                <p>Chapter 5 details how to build a server-persisted application by integrating Vuex with an external
                    API. The primary challenge is keeping the Vuex State (client) synchronized with the Server State.
                    This is achieved by organizing the application data into Vuex <strong>Modules</strong> (like
                    <code>cartModule</code> and <code>productModule</code>). <strong>Actions</strong> play the crucial
                    role of handling all asynchronous server communication (<code>axios</code> calls), committing a
                    synchronous <strong>Mutation</strong> only after receiving the updated data from the server to
                    ensure consistency.</p>
                <h4 id="main-key-ideas-to-remember">Main Key Ideas to Remember</h4>
                <ol>
                    <li><strong>Persistence through Synchronization:</strong> Data is truly saved (persisted) only when
                        the server is updated, and the client Vuex store must always reflect the server&#39;s truth.
                    </li>
                    <li><strong>Modules for Scale:</strong> Divide large application state into isolated Vuex Modules
                        based on function (e.g., products, cart) for better organization.</li>
                    <li><strong>Action = Async Bridge:</strong> Actions are mandatory for all server operations
                        (<code>axios</code>), handling the slow request before committing a quick Mutation.</li>
                    <li><strong>Mutations Synchronize State:</strong> Mutations update the local state, typically by
                        using the <strong>entire updated data payload</strong> returned by the server immediately after
                        a change.</li>
                </ol>
                <h4 id="2-3-practical-examples-i-can-try-right-away">2–3 Practical Examples I Can Try Right Away</h4>
                <ol>
                    <li><strong>MapGetters for Display:</strong> If you have calculated data (like <code>taxRate</code>)
                        in your Vuex store, use <code>mapGetters</code> to link it to a component:
                        <code>computed: { ...mapGetters([&#39;taxRate&#39;]) }</code>. This makes
                        <code>this.taxRate</code> available instantly.</li>
                    <li><strong>Total Calculation Getter:</strong> Define a Getter (in your store Module) that uses the
                        JavaScript <code>reduce</code> function to calculate the sum of an array property (like
                        calculating the total votes or total price).</li>
                    <li><strong>Dispatching on Creation:</strong> Place a dispatch call
                        (<code>this.$store.dispatch(&#39;fetchData&#39;)</code>) inside the <code>created()</code>
                        lifecycle hook of your root component so that data is requested from the server immediately when
                        the app starts.</li>
                </ol>
                <h4 id="3-quick-tips-to-help-apply-what-i-learned">3 Quick Tips to Help Apply What I Learned</h4>
                <ol>
                    <li><strong>Keep Mutations Clean:</strong> Ensure your Mutations only contain one thing: direct,
                        synchronous modification of the State. Never put <code>axios</code> or network code here.</li>
                    <li><strong>Use Modules Early:</strong> Even if your app is small now, start with at least two
                        modules (e.g., <code>user</code> and <code>data</code>) to practice separation of concerns.</li>
                    <li><strong>Return Promises in Actions:</strong> When writing Actions that talk to a server, make
                        sure the Action returns the Promise provided by <code>axios</code> so that any component
                        dispatching the action knows exactly when the server response has been handled.</li>
                </ol>
                <h4 id="3-short-quiz-questions-to-test-basic-understanding">3 Short Quiz Questions to Test Basic
                    Understanding</h4>
                <ol>
                    <li>In a server-persisted application, what is the role of an <strong>Action</strong> that talks to
                        a server?</li>
                    <li>Why is it better to divide a large Vuex store into <strong>Modules</strong>?</li>
                    <li>When a server successfully processes a data change (like adding a cart item), why does the
                        action commit a mutation immediately after receiving the response?</li>
                </ol>







            </div>
        </div>

    </div>


    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>


    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" //
        integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+Y2XIdI6kB1jRVVbR4D9M1zYjFq2D" //
        crossorigin="anonymous"></script>

    <script src="../script.js"> </script>


</body>

</html>